using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace IoC.InstallGenerator
{
    internal static class CodeGenerator
    {
        // T037-T043: Implement code generation logic for IoCInstallerLoader class
        // T050: Performance optimization - direct method calls, no reflection
        // T053: AOT and trimming compatible - no dynamic code, all types known at compile time
        public static string GeneratePartialClass(string className, string namespaceName, IEnumerable<InstallerInfo> installers, string? installOrder = null)
        {
            var sb = new StringBuilder();
            
            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("// T053: This code is AOT and trimming compatible - no reflection, all types known at compile time");
            sb.AppendLine($"namespace {namespaceName}");
            sb.AppendLine("{");
            sb.AppendLine("    using System;");
            sb.AppendLine("    using System.Collections.Generic;");
            sb.AppendLine("    using System.Diagnostics;");
            sb.AppendLine("    using IoC.InstallGenerator.Abstractions;");
            sb.AppendLine();
            sb.AppendLine($"    public static partial class {className}");
            sb.AppendLine("    {");
            sb.AppendLine("        // T038: LoadAll method with container parameter");
            sb.AppendLine("        // T050: Optimized for performance - direct method calls, no reflection overhead");
            sb.AppendLine("        // This method is generated by the IoC Install Generator source generator");
            sb.AppendLine("        public static void LoadAll(IIoCContainer container)");
            sb.AppendLine("        {");
            sb.AppendLine("            var errors = new List<Exception>();");
            sb.AppendLine();
            
            // T044: Apply install order if specified
            var orderedInstallers = ApplyInstallOrder(installers, installOrder);
            
            // Add comment showing the install order that was applied
            if (!string.IsNullOrEmpty(installOrder))
            {
                sb.AppendLine("            // InstallOrder attribute detected - applying order: " + installOrder);
            }
            else
            {
                sb.AppendLine("            // No InstallOrder attribute specified - using discovery order");
            }
            sb.AppendLine();
            
            // T039: Generate installer instantiation and Install() calls
            // T040: Implement try-catch error handling for each installer
            // T050: Direct instantiation - no reflection, maximum performance
            foreach (var installer in orderedInstallers)
            {
                sb.AppendLine("            try");
                sb.AppendLine("            {");
                sb.AppendLine($"                // T039, T050: Direct instantiation and method call - no reflection");
                sb.AppendLine($"                new {installer.FullTypeName}().Install(container);");
                sb.AppendLine($"                Debug.WriteLine($\"[IoC Installer] Loaded: {installer.FullTypeName}\");");
                sb.AppendLine("            }");
                sb.AppendLine("            catch (Exception ex)");
                sb.AppendLine("            {");
                sb.AppendLine($"                // T042: Wrap failed installer exception");
                sb.AppendLine($"                errors.Add(new InstallerException(\"{installer.FullTypeName}\", ex));");
                sb.AppendLine("            }");
                sb.AppendLine();
            }
            
            // T041: Implement AggregateException generation when errors occur
            sb.AppendLine("            if (errors.Count > 0)");
            sb.AppendLine("            {");
            sb.AppendLine("                throw new AggregateException(\"One or more installers failed\", errors);");
            sb.AppendLine("            }");
            sb.AppendLine("        }");
            sb.AppendLine("    }");
            sb.AppendLine("}");
            
            return sb.ToString();
        }

        // Legacy method - kept for backward compatibility
        public static string GenerateLoaderClass(IEnumerable<InstallerInfo> installers, string? installOrder = null)
        {
            var sb = new StringBuilder();
            
            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("// T053: This code is AOT and trimming compatible - no reflection, all types known at compile time");
            sb.AppendLine("namespace IoC.InstallGenerator.Generated");
            sb.AppendLine("{");
            sb.AppendLine("    using System;");
            sb.AppendLine("    using System.Collections.Generic;");
            sb.AppendLine("    using System.Diagnostics;");
            sb.AppendLine("    using IoC.InstallGenerator.Abstractions;");
            sb.AppendLine();
            sb.AppendLine("    public static class IoCInstallerLoader");
            sb.AppendLine("    {");
            sb.AppendLine("        // T038: LoadAll method with container parameter");
            sb.AppendLine("        // T050: Optimized for performance - direct method calls, no reflection overhead");
            sb.AppendLine("        public static void LoadAll(IIoCContainer container)");
            sb.AppendLine("        {");
            sb.AppendLine("            var errors = new List<Exception>();");
            sb.AppendLine();
            
            // T044: Apply install order if specified
            var orderedInstallers = ApplyInstallOrder(installers, installOrder);
            
            // Add comment showing the install order that was applied
            if (!string.IsNullOrEmpty(installOrder))
            {
                sb.AppendLine("            // InstallOrder attribute detected - applying order: " + installOrder);
            }
            else
            {
                sb.AppendLine("            // No InstallOrder attribute specified - using discovery order");
            }
            sb.AppendLine();
            
            // T039: Generate installer instantiation and Install() calls
            // T040: Implement try-catch error handling for each installer
            // T050: Direct instantiation - no reflection, maximum performance
            foreach (var installer in orderedInstallers)
            {
                sb.AppendLine("            try");
                sb.AppendLine("            {");
                sb.AppendLine($"                // T039, T050: Direct instantiation and method call - no reflection");
                sb.AppendLine($"                new {installer.FullTypeName}().Install(container);");
                sb.AppendLine($"                Debug.WriteLine($\"[IoC Installer] Loaded: {installer.FullTypeName}\");");
                sb.AppendLine("            }");
                sb.AppendLine("            catch (Exception ex)");
                sb.AppendLine("            {");
                sb.AppendLine($"                // T042: Wrap failed installer exception");
                sb.AppendLine($"                errors.Add(new InstallerException(\"{installer.FullTypeName}\", ex));");
                sb.AppendLine("            }");
                sb.AppendLine();
            }
            
            // T041: Implement AggregateException generation when errors occur
            sb.AppendLine("            if (errors.Count > 0)");
            sb.AppendLine("            {");
            sb.AppendLine("                throw new AggregateException(\"One or more installers failed\", errors);");
            sb.AppendLine("            }");
            sb.AppendLine("        }");
            sb.AppendLine("    }");
            sb.AppendLine("}");
            
            return sb.ToString();
        }

        // T044: Implement InstallOrderAttribute reading and installer ordering logic
        private static IEnumerable<InstallerInfo> ApplyInstallOrder(IEnumerable<InstallerInfo> installers, string? installOrder)
        {
            var installerList = installers.ToList();
            
            if (string.IsNullOrEmpty(installOrder))
            {
                // No order specified - return in discovery order
                return installerList;
            }

            var orderArray = installOrder!.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries)
                .Select(s => s.Trim())
                .Where(s => !string.IsNullOrEmpty(s))
                .ToArray();
            var ordered = new List<InstallerInfo>();
            var unordered = new List<InstallerInfo>(installerList);

            // First, add installers in the specified order
            foreach (var assemblyName in orderArray)
            {
                var matching = unordered.Where(i => 
                    string.Equals(i.AssemblyName, assemblyName, StringComparison.OrdinalIgnoreCase)).ToList();
                ordered.AddRange(matching);
                foreach (var item in matching)
                {
                    unordered.Remove(item);
                }
            }

            // Then, add any remaining installers that weren't in the order
            ordered.AddRange(unordered);

            return ordered;
        }
    }

    internal class InstallerInfo
    {
        public string FullTypeName { get; set; } = string.Empty;
        public string AssemblyName { get; set; } = string.Empty;
    }
}

